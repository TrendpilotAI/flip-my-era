-- Migration: Create Stories Table
-- This table stores the initial short stories generated by users

BEGIN;

-- Create story status enum if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'story_status') THEN
        CREATE TYPE story_status AS ENUM ('draft', 'generating', 'completed', 'published', 'archived');
    END IF;
END$$;

-- Create stories table if it doesn't exist
CREATE TABLE IF NOT EXISTS stories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    
    -- Basic story information
    name TEXT NOT NULL, -- User's name used in the story
    title TEXT, -- Generated or extracted title
    initial_story TEXT NOT NULL, -- The generated story content
    
    -- Generation metadata
    prompt TEXT, -- The original prompt used for generation
    birth_date DATE, -- User's birth date if provided
    personality_type TEXT, -- Personality type used for generation
    era TEXT, -- Era/time period for the story
    location TEXT, -- Location setting for the story
    gender TEXT, -- Gender preference for the story
    transformed_name TEXT, -- Name transformation applied
    
    -- Generation settings
    prompt_data JSONB, -- Original user input data
    generation_settings JSONB, -- AI model settings used
    
    -- Content metadata
    word_count INTEGER,
    reading_time_minutes INTEGER,
    content_rating TEXT DEFAULT 'general',
    tags TEXT[],
    
    -- Status and workflow
    status story_status DEFAULT 'completed',
    generation_started_at TIMESTAMP,
    generation_completed_at TIMESTAMP,
    
    -- Analytics
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Create indexes for performance if they don't exist
CREATE INDEX IF NOT EXISTS idx_stories_user_id ON stories(user_id);
CREATE INDEX IF NOT EXISTS idx_stories_status ON stories(status);
CREATE INDEX IF NOT EXISTS idx_stories_created_at ON stories(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_stories_user_status ON stories(user_id, status);
CREATE INDEX IF NOT EXISTS idx_stories_name ON stories(name);
CREATE INDEX IF NOT EXISTS idx_stories_personality_type ON stories(personality_type);
CREATE INDEX IF NOT EXISTS idx_stories_era ON stories(era);

-- Create function to update timestamps if it doesn't exist
CREATE OR REPLACE FUNCTION update_stories_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for updating updated_at timestamp if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_stories_updated_at') THEN
        CREATE TRIGGER trigger_stories_updated_at
            BEFORE UPDATE ON stories
            FOR EACH ROW EXECUTE FUNCTION update_stories_updated_at();
    END IF;
END$$;

-- Set up RLS policies
ALTER TABLE stories ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view own stories" ON stories;
DROP POLICY IF EXISTS "Users can insert own stories" ON stories;
DROP POLICY IF EXISTS "Users can update own stories" ON stories;
DROP POLICY IF EXISTS "Users can delete own stories" ON stories;
DROP POLICY IF EXISTS "Service role can manage all stories" ON stories;
DROP POLICY IF EXISTS "Public can view published stories" ON stories;

-- Users can view their own stories
CREATE POLICY "Users can view own stories" ON stories
    FOR SELECT TO authenticated
    USING (
        user_id = auth.jwt() ->> 'sub'
        OR user_id = auth.jwt() ->> 'user_id'
        OR user_id = auth.jwt() ->> 'userId'
    );

-- Users can insert their own stories
CREATE POLICY "Users can insert own stories" ON stories
    FOR INSERT TO authenticated
    WITH CHECK (
        user_id = auth.jwt() ->> 'sub'
        OR user_id = auth.jwt() ->> 'user_id'
        OR user_id = auth.jwt() ->> 'userId'
    );

-- Users can update their own stories
CREATE POLICY "Users can update own stories" ON stories
    FOR UPDATE TO authenticated
    USING (
        user_id = auth.jwt() ->> 'sub'
        OR user_id = auth.jwt() ->> 'user_id'
        OR user_id = auth.jwt() ->> 'userId'
    );

-- Users can delete their own stories
CREATE POLICY "Users can delete own stories" ON stories
    FOR DELETE TO authenticated
    USING (
        user_id = auth.jwt() ->> 'sub'
        OR user_id = auth.jwt() ->> 'user_id'
        OR user_id = auth.jwt() ->> 'userId'
    );

-- Service role can manage all stories (for admin functions)
CREATE POLICY "Service role can manage all stories" ON stories
    FOR ALL TO service_role
    USING (true);

-- Allow public read access to published stories (optional)
CREATE POLICY "Public can view published stories" ON stories
    FOR SELECT TO anon, authenticated
    USING (status = 'published');

COMMIT;
